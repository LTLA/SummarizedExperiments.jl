var documenterSearchIndex = {"docs":
[{"location":"#SummarizedExperiments-for-Julia","page":"Home","title":"SummarizedExperiments for Julia","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SummarizedExperiment package is a staple of the Bioconductor ecosystem, providing a powerful yet user-friendly container for summarized genomics datasets. This repository ports the basic SummarizedExperiment functionality from R to Julia, allowing Julians to conveniently manipulate analysis-ready datasets in the same fashion as R/Bioconductor workflows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SummarizedExperiment class is centered around the idea of assay matrices for experimental data  where the rows are features (most commonly genes) and the columns are samples. Typical use cases include intensities for microarrays or counts for sequencing data. We hold further annotations on the rows and columns in the rowdata and coldata respectively, both of which are synchronized to the assays during subsetting and concatenation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check out Figure 2 of the Orchestrating high-throughput genomic analysis with Bioconductor paper for more details.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Users may install this package from the GitHub repository through the usual process on the Pkg REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/LTLA/SummarizedExperiments.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"And then:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SummarizedExperiments\n\njulia> x = exampleobject(100, 10) # Mocking up an example object\n100x10 SummarizedExperiment\n  assays(3): foo bar whee\n  rownames: Gene1 Gene2 ... Gene99 Gene100\n  rowdata(2): name Type\n  colnames: Patient1 Patient2 ... Patient9 Patient10\n  coldata(3): name Treatment Response\n  metadata(1): version\n\njulia> coldata(x)\n10×3 DataFrame\n Row │ name       Treatment  Response\n     │ String     String     Float64\n─────┼─────────────────────────────────\n   1 │ Patient1   normal     0.197936\n   2 │ Patient2   drug1      0.886853\n   3 │ Patient3   drug2      0.184345\n   4 │ Patient4   drug1      0.271934\n   5 │ Patient5   normal     0.227814\n   6 │ Patient6   drug1      0.357306\n   7 │ Patient7   drug2      0.0882962\n   8 │ Patient8   normal     0.306175\n   9 │ Patient9   normal     0.731478\n  10 │ Patient10  drug2      0.419693\n\njulia> assay(x)\n100×10 Matrix{Int64}:\n 76  77   36  26    9   10  62  88   2  31\n 56  28  100  68   35   19  29  35  17  70\n 72  82   56  72   79    0  20  52  22  24\n 98  59    0  17   27   90  17  22  26  85\n 17   9   44  73   72   52  96  90  68  29\n 62  56   15  24   60   38  79  67  71  90\n etc. etc.","category":"page"},{"location":"#Class-definition","page":"Home","title":"Class definition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SummarizedExperiment","category":"page"},{"location":"#SummarizedExperiments.SummarizedExperiment","page":"Home","title":"SummarizedExperiments.SummarizedExperiment","text":"The SummarizedExperiment class is a Bioconductor container for matrix-like data with annotations on the rows and columns. It is the data structure underlying analysis workflows for many genomics data modalities, ranging from microarrays, bulk and single-cell RNA sequencing, ChIP-seq, epigenomics and beyond.\n\nAny number of arrays (also known as \"assays\") can be stored in the container,  provided they are assigned to unique names and all have the same extents for the first two dimensions. This reflects the fact that we often have multiple experimental readouts of the same shape, e.g., raw counts, normalized values, quality metrics. These assays are held as an OrderedDict so the order of their addition is respected.\n\nThe row and column annotations are stored as DataFrames, with number of rows equal to the number of assay rows and columns, respectively. Any number and type of columns may be present in each DataFrame, with the only constraint being that the first column must be a \"name\" column of strings containing the feature/sample names. If no names are present, the \"name\" column must contain nothings.\n\nEach instance may also contain arbitrary metadata not associated with the rows or columns.\n\n\n\n\n\n","category":"type"},{"location":"#Constructors","page":"Home","title":"Constructors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SummarizedExperiment(\n    assays::DataStructures.OrderedDict{String, AbstractArray},\n    rowdata::DataFrames.DataFrame,\n    coldata::DataFrames.DataFrame, \n    metadata::Dict{String, Any} = Dict{String,Any}()\n)","category":"page"},{"location":"#SummarizedExperiments.SummarizedExperiment-2","page":"Home","title":"SummarizedExperiments.SummarizedExperiment","text":"SummarizedExperiment(assays, rowdata, coldata, metadata = Dict{String,Any}())\n\nCreate an instance of a SummarizedExperiment with the supplied assays and the row/column annotations.\n\nAll entries of assays should have the same extents for the first two dimensions. However, they can otherwise have any number of other dimensions. Each assay can be of different type.\n\nFor rowdata, the number of rows must be equal to the extent of the first dimension for each entry in assays. Similarly, for coldata, the number of rows must be equal to the extent of the second dimension. In both cases, the first column must be called \"name\" and contain a Vector of Strings or Nothings (if no names are available).\n\nassays may also be empty.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> assays = OrderedDict{String, AbstractArray}(\n          \"foobar\" => [[1,2] [3,4] [5,6]], \n          \"whee\" => [[1.2,2.3] [3.4,4.5] [5.6,7.8]]);\n\njulia> rowdata = DataFrame(\n          name = [ \"X\", \"Y\" ],\n          type = [\"protein\", \"transcript\"]);\n\njulia> coldata = DataFrame(\n          name = [ \"a\", \"b\", \"c\" ],\n          treatment = [\"normal\", \"drug1\", \"drug2\"]);\n\njulia> x = SummarizedExperiment(assays, rowdata, coldata)\n2x3 SummarizedExperiment\n  assays(2): foobar whee\n  rownames: X Y\n  rowdata(2): name type\n  colnames: a b c\n  coldata(2): name treatment\n  metadata(0):\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"SummarizedExperiment(assays::DataStructures.OrderedDict{String, AbstractArray})   ","category":"page"},{"location":"#SummarizedExperiments.SummarizedExperiment-Tuple{OrderedDict{String, AbstractArray}}","page":"Home","title":"SummarizedExperiments.SummarizedExperiment","text":"SummarizedExperiment(assays)\n\nCreate an instance of a SummarizedExperiment with the supplied assays.\n\nAll entries of assays should have the same extents for the first two dimensions. However, they can otherwise have any number of other dimensions. Each assay can be of different type. assays should contain at least one assay matrix.\n\nFor the coldata and rowdata, an empty DataFrame is created with a \"name\" column containing all nothings.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> assays = OrderedDict{String, AbstractArray}(\n          \"foobar\" => [[1,2] [3,4] [5,6]], \n          \"whee\" => [[1.2,2.3] [3.4,4.5] [5.6,7.8]]);\n\njulia> x = SummarizedExperiment(assays)\n2x3 SummarizedExperiment\n  assays(2): foobar whee\n  rownames:\n  rowdata(1): name\n  colnames:\n  coldata(1): name\n  metadata(0):\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"SummarizedExperiment()","category":"page"},{"location":"#SummarizedExperiments.SummarizedExperiment-Tuple{}","page":"Home","title":"SummarizedExperiments.SummarizedExperiment","text":"SummarizedExperiment()\n\nCreate an empty SummarizedExperiment with no assays and empty row/column annotations.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> SummarizedExperiment()\n0x0 SummarizedExperiment\n  assays(0):\n  rownames:\n  rowdata(1): name\n  colnames:\n  coldata(1): name\n  metadata(0):\n\n\n\n\n\n","category":"method"},{"location":"#Getters","page":"Home","title":"Getters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"size(x::SummarizedExperiment)","category":"page"},{"location":"#Base.size-Tuple{SummarizedExperiment}","page":"Home","title":"Base.size","text":"size(x::SummarizedExperiment)\n\nReturn a 2-tuple containing the number of rows and columns in x.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> size(x)\n(20, 10)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"assay(x::SummarizedExperiment)","category":"page"},{"location":"#SummarizedExperiments.assay-Tuple{SummarizedExperiment}","page":"Home","title":"SummarizedExperiments.assay","text":"assay(x[, i]; check = true)\n\nReturn the requested assay in x. i may be an integer specifying an index or a string containing the name. If i is not supplied, the first assay is returned. \n\nThe returned assay should have the same extents as x for the first two dimensions. If check = true, this function will verify that this expectation is satisfied. Any failures will cause warnings to be emitted.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\n# All of these give the same value.\njulia> assay(x);\n\njulia> assay(x, 1);\n\njulia> assay(x, \"foo\");\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"assays(x::SummarizedExperiment)","category":"page"},{"location":"#SummarizedExperiments.assays-Tuple{SummarizedExperiment}","page":"Home","title":"SummarizedExperiments.assays","text":"assays(x; check = true)\n\nReturn all assays from x as an OrderedDict where the keys are the assay names. Each returned assay should have the same extents as x for the first two dimensions. If check = true, this function will verify that this expectation is satisfied. Any failures will cause warnings to be emitted.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> collect(keys(assays(x)))\n3-element Vector{String}:\n \"foo\"\n \"bar\"\n \"whee\"\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"rowdata(x::SummarizedExperiment)","category":"page"},{"location":"#SummarizedExperiments.rowdata-Tuple{SummarizedExperiment}","page":"Home","title":"SummarizedExperiments.rowdata","text":"rowdata(x; check = true)\n\nReturn the row annotations as a DataFrame with number of rows equal to the number of rows in x. The first column is called \"name\" and contains the row names of x; this can either be an AbstractVector{AbstractString} or a Vector{Nothing} (if no row names are available).\n\nIf check = true, this function will verify that the above expectations on the returned DataFrame are satisfied. Any failures will cause warnings to be emitted.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> names(rowdata(x))\n2-element Vector{String}:\n \"name\"\n \"Type\"\n\njulia> size(rowdata(x))\n(20, 2)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"coldata(x::SummarizedExperiment)","category":"page"},{"location":"#SummarizedExperiments.coldata-Tuple{SummarizedExperiment}","page":"Home","title":"SummarizedExperiments.coldata","text":"coldata(x, check = true)\n\nReturn the column annotations as a DataFrame with number of rows equal to the number of columns in x. The first column is called \"name\" and contains the column names of x; this can either be a Vector{String} or a Vector{Nothing} (if no column names are available).\n\nIf check = true, this function will verify that the expectations on the returned DataFrame are satisfied. Any failures will cause warnings to be emitted.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> names(coldata(x))\n3-element Vector{String}:\n \"name\"\n \"Treatment\"\n \"Response\"\n\njulia> size(coldata(x))\n(10, 3)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"metadata(x::SummarizedExperiment)","category":"page"},{"location":"#SummarizedExperiments.metadata-Tuple{SummarizedExperiment}","page":"Home","title":"SummarizedExperiments.metadata","text":"metadata(x)\n\nReturn metadata from x as a Dict where the keys are the metadata field names.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> metadata(x)\nDict{String, Any} with 1 entry:\n  \"version\" => \"1.1.0\"\n\n\n\n\n\n","category":"method"},{"location":"#Setters","page":"Home","title":"Setters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"setassay!(x::SummarizedExperiment, value::AbstractArray)","category":"page"},{"location":"#SummarizedExperiments.setassay!-Tuple{SummarizedExperiment, AbstractArray}","page":"Home","title":"SummarizedExperiments.setassay!","text":"setassay!(x[, i], value)\n\nSet the requested assay in x to any array-like value. The first two dimensions of value must have extent equal to those of x.\n\ni may be an integer specifying an index, in which case it must be positive and no greater than length(assays(x)); or a string containing the name, in which case it may be an existing or new name. If i is not supplied, value is set as the first assay of x.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> first_sum = sum(assay(x));\n\njulia> second_sum = sum(assay(x, 2));\n\njulia> setassay!(x, assay(x, 2)); # Replacing the first assay with the second.\n\njulia> first_sum == sum(assay(x))\nfalse\n\njulia> second_sum == sum(assay(x))\ntrue\n\njulia> setassay!(x, 1, assay(x, 2)); # More explicit forms of the above.\n\njulia> setassay!(x, \"foo\", assay(x, 2));\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"setassays!(x::SummarizedExperiment, value::DataStructures.OrderedDict{String,AbstractArray})","category":"page"},{"location":"#SummarizedExperiments.setassays!-Tuple{SummarizedExperiment, OrderedDict{String, AbstractArray}}","page":"Home","title":"SummarizedExperiments.setassays!","text":"setassays!(x, value)\n\nSet assays in x to value, an OrderedDict where the keys are assay names and the values are arrays. All arrays in value should have the same extents as x for the first two dimensions.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> length(assays(x))\n3\n\njulia> refresh = copy(assays(x));\n\njulia> delete!(refresh, \"foo\");\n\njulia> setassays!(x, refresh)\n\njulia> length(assays(x))\n2\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"setrowdata!(x::SummarizedExperiment, value::DataFrames.DataFrame)","category":"page"},{"location":"#SummarizedExperiments.setrowdata!-Tuple{SummarizedExperiment, DataFrame}","page":"Home","title":"SummarizedExperiments.setrowdata!","text":"setrowdata!(x, value)\n\nSet the row annotations in x to value.\n\nIf value is a DataFrame, the first column should be called \"name\" and contain the row names of x; this can either be an AbstractVector{AbstractString} or a Vector{Nothing} (if no row names are available).\n\nIf value is nothing, this is considered to be equivalent to a DataFrame with one \"name\" column containing nothings.\n\nThe return value is a reference to the modified x.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> # using DataFrames\n\njulia> replacement = copy(rowdata(x));\n\njulia> replacement[!,\"foobar\"] = [ rand() for i in 1:size(x)[1] ];\n\njulia> setrowdata!(x, replacement);\n\njulia> names(rowdata(x))\n3-element Vector{String}:\n \"name\"\n \"Type\"\n \"foobar\"\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"setcoldata!(x::SummarizedExperiment, value::DataFrames.DataFrame)","category":"page"},{"location":"#SummarizedExperiments.setcoldata!-Tuple{SummarizedExperiment, DataFrame}","page":"Home","title":"SummarizedExperiments.setcoldata!","text":"setcoldata!(x, value)\n\nSet the column annotations in x to value.\n\nIf value is a DataFrame, the first column should be called \"name\" and contain the column names of x; this can either be a Vector{String} or a Vector{Nothing} (if no column names are available).\n\nIf value is nothing, this is considered to be equivalent to a DataFrame with one \"name\" column containing nothings.\n\nThe return value is a reference to the modified x.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> replacement = copy(coldata(x));\n\njulia> replacement[!,\"foobar\"] = [ rand() for i in 1:size(x)[2] ];\n\njulia> setcoldata!(x, replacement);\n\njulia> names(coldata(x))\n4-element Vector{String}:\n \"name\"\n \"Treatment\"\n \"Response\"\n \"foobar\"\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"setmetadata!(x::SummarizedExperiment, value::Dict{String,Any})","category":"page"},{"location":"#SummarizedExperiments.setmetadata!-Tuple{SummarizedExperiment, Dict{String, Any}}","page":"Home","title":"SummarizedExperiments.setmetadata!","text":"setmetadata!(x, value)\n\nSet metadata in x to value, a Dict where the keys are the metadata field names.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> setmetadata!(x, Dict{String,Any}(\"foo\" => 200));\n\njulia> metadata(x)\nDict{String, Any} with 1 entry:\n  \"foo\" => 200\n\n\n\n\n\n","category":"method"},{"location":"#Subsetting","page":"Home","title":"Subsetting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Base.getindex(x::SummarizedExperiment, i, j)","category":"page"},{"location":"#Base.getindex-Tuple{SummarizedExperiment, Any, Any}","page":"Home","title":"Base.getindex","text":"getindex(x::SummarizedExperiment, i, j)\n\nSubset x by the rows or columns based on i and j, respectively. Types for the arguments to i and j are similar to those for arrays:\n\nAn integer Vector containing indices.\nAn Int containing a single index.\nA boolean Vector of length equal to the relevant dimension, indicating whether each entry of that dimension should be retained.\nA : operator to retain the entirety of a dimension's extent.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> x[1,:]\n1x10 SummarizedExperiment\n  assays(3): foo bar whee\n  rownames: Gene1\n  rowdata(2): name Type\n  colnames: Patient1 Patient2 ... Patient9 Patient10\n  coldata(3): name Treatment Response\n  metadata(1): version\n\njulia> x[:,1:5]\n20x5 SummarizedExperiment\n  assays(3): foo bar whee\n  rownames: Gene1 Gene2 ... Gene19 Gene20\n  rowdata(2): name Type\n  colnames: Patient1 Patient2 ... Patient4 Patient5\n  coldata(3): name Treatment Response\n  metadata(1): version\n\njulia> keep = [ i > 5 for i in 1:size(x)[1] ];\n\njulia> x[keep,1:2]\n15x2 SummarizedExperiment\n  assays(3): foo bar whee\n  rownames: Gene6 Gene7 ... Gene19 Gene20\n  rowdata(2): name Type\n  colnames: Patient1 Patient2\n  coldata(3): name Treatment Response\n  metadata(1): version\n\n\n\n\n\n","category":"method"},{"location":"#Subset-assignment","page":"Home","title":"Subset assignment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Base.setindex!(x::SummarizedExperiment, value::SummarizedExperiment, i, j)","category":"page"},{"location":"#Base.setindex!-Tuple{SummarizedExperiment, SummarizedExperiment, Any, Any}","page":"Home","title":"Base.setindex!","text":"setindex!(x, value, i, j)\n\nAssign the SummarizedExperiment value to a subset of SummarizedExperiment x by the rows or columns based on i and j, respectively. Types for the arguments to i and j are similar to those for arrays:\n\nAn integer Vector containing indices.\nAn Int containing a single index.\nA boolean Vector of length equal to the relevant dimension, indicating whether each entry of that dimension should be retained.\nA : operator to retain the entirety of a dimension's extent.\n\nOn assignment, the assay values in the specified subset of x will be replaced by the corresponding values in value. Rows of the rowdata(x) and coldata(x) will be replaced by those in value, according to i and j respectively. Metadata fields in metadata(value) will be added to or overwrite those in metadata(x).\n\nIt is assumed that x and value contain the same name, order and type of columns in their rowdata and coldata. Similarly, both objects should contain the same name, order and type of arrays in their assays.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> x[:,1] = x[:,2];\n\njulia> sn = coldata(x)[!,\"name\"];\n\njulia> sn[1] == sn[2]\ntrue\n\njulia> y = assay(x);\n\njulia> y[:,1] == y[:,2]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Concatenation","page":"Home","title":"Concatenation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Base.hcat(A::Vararg{SummarizedExperiment})","category":"page"},{"location":"#Base.hcat-Tuple{Vararg{SummarizedExperiment}}","page":"Home","title":"Base.hcat","text":"hcat(A::Vararg{SummarizedExperiment})\n\nHorizontally concatenate one or more SummarizedExperiment objects. The input objects must satisfy the following constraints:\n\nAll objects must have the same number of rows, which are assumed to be in the same order.\nAll objects must have DataFrames in their coldata with the same type and names of all columns (though they may be ordered differently).\nAll objects must have the same names and types of assays; for a given assay name, the dimensions of the corresponding arrays across all A should be the same except for the second dimension. \n\nThis function returns a single SummarizedExperiment instance where the number of columns is equal to the sum of the number of columns across all objects in A. The number of rows in the output object is the same as the number of rows in any object in A. The order of columns in the output coldata is the same as that of the first object. The output rowdata is created by combining columns horizontally across rowdata of all objects in A; if columns have duplicate names, only the first instance of each column is retained.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 20);\n\njulia> y = exampleobject(20, 30);\n\njulia> z = hcat(x, y)\n20x50 SummarizedExperiment\n  assays(3): foo bar whee\n  rownames: Gene1 Gene2 ... Gene19 Gene20\n  rowdata(2): name Type\n  colnames: Patient1 Patient2 ... Patient29 Patient30\n  coldata(3): name Treatment Response\n  metadata(1): version\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Base.vcat(A::Vararg{SummarizedExperiment})","category":"page"},{"location":"#Base.vcat-Tuple{Vararg{SummarizedExperiment}}","page":"Home","title":"Base.vcat","text":"vcat(A::Vararg{SummarizedExperiment})\n\nVertically concatenate one or more SummarizedExperiment objects. The input objects must satisfy the following constraints:\n\nAll objects must have the same number of columns, which are assumed to be in the same order.\nAll objects must have DataFrames in their rowdata with the same type and names of all columns (though they may be ordered differently).\nAll objects must have the same names and types of assays; for a given assay name, the dimensions of the corresponding arrays across all A should be the same except for the first dimension. \n\nThis function returns a single SummarizedExperiment instance where the number of rows is equal to the sum of the number of rows across all objects in A. The number of columns in the output object is the same as the number of columns in any object in A. The order of columns in the output rowdata is the same as that of the first object. The output coldata is created by combining columns horizontally across coldata of all objects in A; if columns have duplicate names, only the first instance of each column is retained.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> y = exampleobject(30, 10);\n\njulia> z = vcat(x, y)\n50x10 SummarizedExperiment\n  assays(3): foo bar whee\n  rownames: Gene1 Gene2 ... Gene29 Gene30\n  rowdata(2): name Type\n  colnames: Patient1 Patient2 ... Patient9 Patient10\n  coldata(3): name Treatment Response\n  metadata(1): version\n\n\n\n\n\n","category":"method"},{"location":"#Miscellaneous","page":"Home","title":"Miscellaneous","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Base.copy(x::SummarizedExperiment)","category":"page"},{"location":"#Base.copy-Tuple{SummarizedExperiment}","page":"Home","title":"Base.copy","text":"copy(x::SummarizedExperiment)\n\nReturn a copy of x, where all components are identically-same as those in x.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> x2 = copy(x);\n\njulia> setrowdata!(x2, nothing);\n\njulia> size(rowdata(x)) # Change to reference is only reflected in x2.\n(20, 2)\n\njulia> size(rowdata(x2))\n(20, 1)\n\njulia> insertcols!(coldata(x), 2, \"WHEE\" => 1:10); # Otherwise, references point to the same object.\n\njulia> names(coldata(x2))\n4-element Vector{String}:\n \"name\"\n \"WHEE\"\n \"Treatment\"\n \"Response\"\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Base.deepcopy(x::SummarizedExperiment)","category":"page"},{"location":"#Base.deepcopy-Tuple{SummarizedExperiment}","page":"Home","title":"Base.deepcopy","text":"deepcopy(x::SummarizedExperiment)\n\nReturn a deep copy of x and all of its components.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10);\n\njulia> x2 = deepcopy(x);\n\njulia> setrowdata!(x2, nothing);\n\njulia> size(rowdata(x)) # Change to reference is only reflected in x2.\n(20, 2)\n\njulia> size(rowdata(x2))\n(20, 1)\n\njulia> insertcols!(coldata(x), 2, \"WHEE\" => 1:10); # References now point to different objects.\n\njulia> names(coldata(x2))\n3-element Vector{String}:\n \"name\"\n \"Treatment\"\n \"Response\"\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Base.show(io::IO, x::SummarizedExperiment)","category":"page"},{"location":"#Base.show-Tuple{IO, SummarizedExperiment}","page":"Home","title":"Base.show","text":"show(io::IO, x::SummarizedExperiment)\n\nShow a summary of x, printing the details to the specified io device.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"exampleobject(nrow::Int, ncol::Int)","category":"page"},{"location":"#SummarizedExperiments.exampleobject-Tuple{Int64, Int64}","page":"Home","title":"SummarizedExperiments.exampleobject","text":"exampleobject(nrow, ncol)\n\nCreate an example SummarizedExperiment object with the specified number of rows and columns. This is to be used to improve the succinctness of examples and tests.\n\nExamples\n\njulia> using SummarizedExperiments\n\njulia> x = exampleobject(20, 10)\n20x10 SummarizedExperiment\n  assays(3): foo bar whee\n  rownames: Gene1 Gene2 ... Gene19 Gene20\n  rowdata(2): name Type\n  colnames: Patient1 Patient2 ... Patient9 Patient10\n  coldata(3): name Treatment Response\n  metadata(1): version\n\n\n\n\n\n","category":"method"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is maintained by Aaron Lun (@LTLA). If you have bug reports or feature requests, please post them as issues at the GitHub repository.","category":"page"}]
}
